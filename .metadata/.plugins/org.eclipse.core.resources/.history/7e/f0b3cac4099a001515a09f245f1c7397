package wednesday.cryptoanalysis;

import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Arrays;
import java.util.Scanner;

import javax.swing.JFileChooser;

public class Cryptoanalysis {

	public static final int NUM_ASCII_CHAR = 128;
	public static final int SPACE_CODE = 32;
	public static final int TILDE_CODE = '~';

	public static void main(String[] arg) {
		 String encryptedText =
					 "Ajb vnf guj luqv akjvojufq  . Sk qkkj egvfs Rkhfwu Lumemu'q akhhfjvq kj vnf ohifjbojc essoxew kg Dofck Ckqve , nfsf'q Ffsjejbk Tkssfq vk qnkr vnf ohifvukuq zkujc dkz nkr ov'q bkjf    Iv'q vnf qehf fxfsz quhhfs . Nk-kjf neq fxfs coxfj hf ejzvnojc kj e iwevf . Tnfz hebf hf akhifvf gks hz iweaf vnf xfsz hkhfjv I ckv ojvk vnf gosqv vfeh; vnev'q rnev vnfz veucnv hf ejb ov'ww df vnev rez ujvow I wfexf . Tnf nocnfs puewovz iwezfsq vnev akhf - ejb Dofck Ckqve oq puewovz - vnf csfevfs vnf akhifvovokj roww df ejb vnf dfvvfs ov'ww df gks vnf vfeh .Ajb gfes jkv ( ks , ewvfsjevoxfwz , bkj'v cfv vkk ftaovfb)  , Tkssfq neq jk iwejq vk vuam veow ejb suj ejb wfexf noq iezanfamq dfnojb .    I bkj'v nexf ejz iwejq vk hkxf erez socnv jkr .    Ig rf woqvfjfb vk eww vnf suhkusq rf'b nexf 50 iwezfsq . Nkr'q jkv vnf socnv vohf vk df vnojmojc edkuv Cnfwqfe . I'h qusf vnf awud oq rksmojc vk ohiskxf vnf vfeh , duv eww vnev hevvfsq socnv jkr oq vnf Wkswb Cui .Om , vnev dov edkuv vnf 50 iwezfsq hebf hf anuamwf .  Noaf kjf , Ffsjejbk .Nkr , oj ej obfew rkswb , rf rkuwb ifsneiq cfv vnfqf rksbq gskh Lumemu , rnkh rf'b womf vk dfakhf wfcfjbesz ev Cnfwqfe .  Buv rf bkj'v woxf oj ej obfew rkswb , ejb ojqvfeb rf cfv vnfqf rksbq gskh Tkssfq , rnkh rf'b womf vk dfakhf e wkjc-gksckvvfj hfhksz ev Cnfwqfe .  Aweq .Tnev dfojc qeob , qojaf ov'q deqoaewwz ej ohikqqodwf vk veqm vk sob kusqfwxfq kg vnf Â£100h gwki , ev wfeqv nf'q ckv vnf socnv evvovubf .  Hussez?";
		System.out.println("The encrypted text is:");
		System.out.println(encryptedText);
		int[] freqs = createFreqTable(encryptedText);
		displayFrequencies(freqs);
		char[] key = DecryptUtilities.getDecryptionKey(freqs);
		crackEncryption(encryptedText, key);
	}

	/*
	 * This method creates a frequency table of the ASCII characters in a given
	 * String. Any non ASCII characters are ignored.
	 */
	public static int[] createFreqTable(String encryptedText) {
		return null;

	}

	// a method to show the frequencies of characters
	// in the encrypted text.
	public static void displayFrequencies(int[] freqs) {
		System.out.println("Frequencies of characters.");
		System.out.println("Character - Frequency");
		int limit = freqs.length - 1;
		for (int i = SPACE_CODE; i < limit; i++)
			System.out.println((char) i + "\t" + freqs[i]);
	}

	/*
	 * This method displays the decypted version of the encrypted text based on
	 * the current key. The user is asked if they want to make a change to the
	 * key. This is repeated until the user is done making changes.
	 */
	public static void crackEncryption(String encryptedText, char[] key) {
		boolean keepGoing = true;
		Scanner keyboard = new Scanner(System.in);
		displayKey(key);
		while (keepGoing) {
			String clearText = applyKey(encryptedText, key);
			System.out
					.println("\nThe current version of the decrypted text is: ");
			System.out.println("\n" + clearText);
			keepGoing = keepGoing(keyboard);
			if (keepGoing)
				makeChange(key, keyboard);
		}
		showFinal(encryptedText, key);
	}

	// a method to ask the user if they want to keep going
	// and return true if they enter 'y' or 'Y'. Otherwise
	// the method returns false.
	public static boolean keepGoing(Scanner keyboard) {
		System.out.println("Do you want to make a change to the key?");
		System.out.print("Enter 'Y' or 'y' to make change: ");
		String response = keyboard.nextLine();
		return response.length() > 0
				&& (response.charAt(0) == 'Y' || response.charAt(0) == 'y');
	}

	/*
	 * Show final version of key and text
	 */
	public static void showFinal(String encryptedText, char[] key) {
		displayKey(key);
		String clearText = applyKey(encryptedText, key);
		System.out.println("The final version of the decrypted text is: ");
		System.out.println(clearText);
	}

	/*
	 * Ask user for change to key. Causes a swap.
	 */
	public static void makeChange(char[] key, Scanner keyboard) {
		char[] charsToSwap = getCharsToSwap(keyboard);
		int indexOldDecryptChar = -1;
		int indexNewDecryptChar = -1;
		int index = 0;
		while (index < key.length
				&& (indexOldDecryptChar == -1 || indexNewDecryptChar == -1)) {
			if (key[index] == charsToSwap[0])
				indexOldDecryptChar = index;
			if (key[index] == charsToSwap[1])
				indexNewDecryptChar = index;
			index++;
		}
		swap(key, indexOldDecryptChar, indexNewDecryptChar);
	}

	// Method to get the two characters to change in the key.
	//
	// I assume keyboard is connected to System.in
	//
	// If more than 1 character is typed in I simply take the first
	// character of the line. If no characters or type in a
	// runtime error will occur
	//
	// returns an array of length 2
	public static char[] getCharsToSwap(Scanner keyboard) {
		char[] result = new char[2];
		System.out.print("Enter the decrypt character you want to change: ");
		result[0] = keyboard.nextLine().charAt(0);
		System.out.print("Enter what the character " + result[0] + " should"
				+ " decrypt to instead: ");
		result[1] = keyboard.nextLine().charAt(0);
		System.out.println(result[0] + "'s will now decrypt to " + result[1]
				+ "'s and vice versa.");
		return result;
	}

	// a method to swap two elements in an array
	// I expect i and j to both be in bounds
	static void swap(char[] data, int i, int j) {
		char temp = data[i];
		data[i] = data[j];
		data[j] = temp;
	}

	/*
	 * Display the current version of the key for the ASCII characters 32
	 * (space) to 126 (tilde~)
	 */
	public static void displayKey(char[] key) {
		System.out.println("\nThe current version of the key"
				+ "for ASCII characters 32 to 126 is: ");
		for (int i = SPACE_CODE; i <= TILDE_CODE; i++) {
			System.out.println("Encrypt character: " + (char) i
					+ ", decrypt character: " + key[i]);
		}
	}

	/*
	 * This method applys the key to the encrypted text to create a clear
	 * version of the encrypted message.
	 */
	public static String applyKey(String encryptedText, char[] key) {
		return applyKey(encryptedText, key, encryptedText.length());
	}

	/*
	 * This method applys the key to the encrypted text to create a clear
	 * version of the encrypted message.
	 */
	public static String applyKey(String encryptedText, char[] key, int numChars) {
		String result = "";
		for (int i = 0; i < numChars; i++) {
			char ch = encryptedText.charAt(i);
			int index = (int) ch;
			result += key[index];
		}
		return result;
	}

	private static class DecryptUtilities {

		private static final int NUM_ASCII_CHARS = 128;
		private static final int SPACE_CODE = ' ';

		// List of ASCII code for frequencies of occurrence in
		// normal text from most frequent to least frequent
		// based on text files at Project Gutenberg.
		private static String STANDARD_FREQS_STRING = " etaonisrhdlucmfwgy,pb.vkIT-AE\"S"
				+ "NORH'CLMBP_DGWF1x;jUYq:*V2J0z!?K83X94567)"
				+ "([]/|Q=Z#&+"
				+ "}{$~^`%@><\\";

		private static final char[] STANDARD_FREQS = new char[STANDARD_FREQS_STRING
				.length()];
		private static final int ASSUMED_ENCRYTPED_CHARS = STANDARD_FREQS_STRING
				.length();

		static {
			// fill STANDARD FREQS array
			assert STANDARD_FREQS.length == STANDARD_FREQS_STRING.length() : "char array and String not same length";
			for (int i = 0; i < STANDARD_FREQS.length; i++)
				STANDARD_FREQS[i] = STANDARD_FREQS_STRING.charAt(i);
		}

		private DecryptUtilities() {

		}

		/**
		 * A method to select a file and convert it to a String. Currently
		 * hardcoded to url with file to simplify lab.
		 * 
		 * @return A String version of the hard coded file
		 */
		public static String convertFileToString() {
			StringBuilder sb = new StringBuilder();
			String fileURL = "http://userweb.cs.utexas.edu/~scottm/fb/2010/JavaFiles/sub.txt";
			try {
				URL location = new URL(fileURL);
				InputStreamReader in = new InputStreamReader(
						location.openStream());
				Scanner sc = new Scanner(in);
				while (sc.hasNextLine()) {
					sb.append(sc.nextLine());
					sb.append("\n");
				}
				sc.close();
			} catch (IOException e) {
				System.out.println("Unable to read file from");
				System.out.println(e);
				// if any problems occur reset sb.
				// The returned String will now be an empty String
				sb = new StringBuilder();
			}
			return sb.toString();
		}

		private static File pickFile() {
			JFileChooser chooser = new JFileChooser(".");
			int retval = chooser.showOpenDialog(null);
			File f = null;
			chooser.requestFocusInWindow();
			if (retval == JFileChooser.APPROVE_OPTION)
				f = chooser.getSelectedFile();
			return f;
		}

		/**
		 * Determine the probable key to decrypt a message. This assumes a
		 * message was encrypted with a substitution cipher and and the 128
		 * ASCII characters.
		 * 
		 * @param freqs
		 *            the frequencies of characters in the encrypted text.
		 *            freq[0] is the frquency of ASCII 0, freq[1] is the
		 *            frequency of ASCII 1 and so forth. freqs may not be null
		 *            and freqs.length must equal 128.
		 * @return the decryption key based onthe frequency analysis. The index
		 *         of an element in the returned array is the ASCII code for the
		 *         encrypted characters and the element is the probable
		 *         decryption charatacter.
		 */
		public static char[] getDecryptionKey(int[] freqs) {
			if (freqs == null)
				throw new IllegalArgumentException(
						"The parameter freqs cannot be null");
			else if (freqs.length != NUM_ASCII_CHARS)
				throw new IllegalArgumentException(
						"The length of the parameter freqs" + "must be "
								+ NUM_ASCII_CHARS
								+ ". The length of the parameter you sent: "
								+ freqs.length);

			// get a temp array with the freqs of the chars assumed
			// to be encrypted.
			int[] tempFreqs = new int[ASSUMED_ENCRYTPED_CHARS];
			System.arraycopy(freqs, 32, tempFreqs, 0, tempFreqs.length);
			CharFreqPair[] rawData = new CharFreqPair[tempFreqs.length];
			for (int i = 0; i < rawData.length; i++)
				rawData[i] = new CharFreqPair((char) (i + SPACE_CODE), freqs[i
						+ SPACE_CODE]);
			Arrays.sort(rawData);
			reverse(rawData);
			return makeResult(rawData);

		}

		// make the resulting key
		private static char[] makeResult(CharFreqPair[] rawData) {
			char[] result = new char[NUM_ASCII_CHARS];
			// copy over the chars with codes 0 to 31. We assume those are
			// not encrypted
			for (int i = 0; i < SPACE_CODE; i++)
				result[i] = (char) i;
			// Create the key based on standard
			// distribution of ascii characters.
			//
			// The encrypt character is rawData[i].ch.
			// The decrypt character is STANDARD_FREQS[i].
			for (int i = 0; i < rawData.length; i++) {
				result[(int) (rawData[i].ch)] = (char) STANDARD_FREQS[i];
			}
			// take care of ASCII code 127, DEL. Assume not used
			result[NUM_ASCII_CHARS - 1] = (char) (NUM_ASCII_CHARS - 1);
			return result;
		}

		// reverse the array
		private static void reverse(CharFreqPair[] data) {
			CharFreqPair temp;
			int limit = data.length / 2;
			for (int i = 0, j = data.length - 1; i < limit; i++, j--) {
				temp = data[i];
				data[i] = data[j];
				data[j] = temp;
			}
		}

		private static class CharFreqPair implements Comparable<CharFreqPair> {

			private char ch;
			private int freq;

			public CharFreqPair(char c, int f) {
				ch = c;
				freq = f;
			}

			public int compareTo(CharFreqPair other) {
				return freq - other.freq;
			}

			public boolean equals(Object other) {
				if (other == null || other.getClass() != getClass())
					return false;
				return freq == ((CharFreqPair) other).freq;
			}

			public int hashCode() {
				return freq * 1337;
			}

			public String toString() {
				return ch + ": " + freq;
			}
		}

		// public static void main(String[] args) {
		// String text =
		// "Ajb vnf guj luqv akjvojufq  . Sk qkkj egvfs Rkhfwu Lumemu'q akhhfjvq kj vnf ohifjbojc essoxew kg Dofck Ckqve , nfsf'q Ffsjejbk Tkssfq vk qnkr vnf ohifvukuq zkujc dkz nkr ov'q bkjf    Iv'q vnf qehf fxfsz quhhfs . Nk-kjf neq fxfs coxfj hf ejzvnojc kj e iwevf . Tnfz hebf hf akhifvf gks hz iweaf vnf xfsz hkhfjv I ckv ojvk vnf gosqv vfeh; vnev'q rnev vnfz veucnv hf ejb ov'ww df vnev rez ujvow I wfexf . Tnf nocnfs puewovz iwezfsq vnev akhf - ejb Dofck Ckqve oq puewovz - vnf csfevfs vnf akhifvovokj roww df ejb vnf dfvvfs ov'ww df gks vnf vfeh .Ajb gfes jkv ( ks , ewvfsjevoxfwz , bkj'v cfv vkk ftaovfb)  , Tkssfq neq jk iwejq vk vuam veow ejb suj ejb wfexf noq iezanfamq dfnojb .    I bkj'v nexf ejz iwejq vk hkxf erez socnv jkr .    Ig rf woqvfjfb vk eww vnf suhkusq rf'b nexf 50 iwezfsq . Nkr'q jkv vnf socnv vohf vk df vnojmojc edkuv Cnfwqfe . I'h qusf vnf awud oq rksmojc vk ohiskxf vnf vfeh , duv eww vnev hevvfsq socnv jkr oq vnf Wkswb Cui .Om , vnev dov edkuv vnf 50 iwezfsq hebf hf anuamwf .  Noaf kjf , Ffsjejbk .Nkr , oj ej obfew rkswb , rf rkuwb ifsneiq cfv vnfqf rksbq gskh Lumemu , rnkh rf'b womf vk dfakhf wfcfjbesz ev Cnfwqfe .  Buv rf bkj'v woxf oj ej obfew rkswb , ejb ojqvfeb rf cfv vnfqf rksbq gskh Tkssfq , rnkh rf'b womf vk dfakhf e wkjc-gksckvvfj hfhksz ev Cnfwqfe .  Aweq .Tnev dfojc qeob , qojaf ov'q deqoaewwz ej ohikqqodwf vk veqm vk sob kusqfwxfq kg vnf Â£100h gwki , ev wfeqv nf'q ckv vnf socnv evvovubf .  Hussez?";
		// // String text = "Godzilla";
		// Map<Character, Integer> m = Histogram.createHistogram(text);
		// System.out.println(text);
		// System.out.println(m);
		// System.out.println(InglishLettersStatistic.LETTERS);
		// String tex = "";
		// List<Character> l = new ArrayList<>();
		// for (Map.Entry<Character, Integer> entry : m.entrySet()) {
		// l.add(entry.getKey());
		// }
		// System.out.println(l);
		// for (int i = 0; i < text.length(); i++) {
		// char letter = text.charAt(i);
		// if (Character.isLowerCase(letter)) {
		// switch (letter) {
		// case 'a':
		// tex += 'c';
		// break;
		// case 'b':
		// tex += 'd';
		// break;
		// case 'c':
		// tex += 'g';
		// break;
		// case 'd':
		// tex += 'b';
		// break;
		// case 'e':
		// tex += 'a';
		// break;
		// case 'f':
		// tex += 'e';
		// break;
		// case 'g':
		// tex += 'f';
		// break;
		// case 'h':
		// tex += 'm';
		// break;
		// case 'i':
		// tex += 'p';
		// break;
		// case 'j':
		// tex += 'n';
		// break;
		// case 'k':
		// tex += 'o';
		// break;
		// case 'l':
		// tex += 'm';
		// break;
		// case 'm':
		// tex += 'k';
		// break;
		// case 'n':
		// tex += 'h';
		// break;
		// case 'o':
		// tex += 'i';
		// break;
		// case 'p':
		// tex += 'q';
		// break;
		// case 'q':
		// tex += 's';
		// break;
		// case 'r':
		// tex += 'w';
		// break;
		// case 's':
		// tex += 'r';
		// break;
		// case 't':
		// tex += 'j';
		// break;
		// case 'u':
		// tex += 'u';
		// break;
		// case 'v':
		// tex += 't';
		// break;
		// case 'w':
		// tex += 'l';
		// break;
		// case 'x':
		// tex += 'v';
		// break;
		// case 'y':
		// tex += 'z';
		// break;
		// case 'z':
		// tex += 'y';
		// break;
		//
		// default:
		// break;
		// }
		// }
		// if (Character.isUpperCase(letter)||Character.isWhitespace(letter)) {
		//
		// tex+=letter;
		// }
		// // if (Character.isLetter(letter) && Character.isLowerCase(letter) &&
		// l.contains(letter)) {
		// // // System.out.println(letter);
		// // int pos = l.indexOf(letter);
		// // // System.out.println(pos);
		// // System.out.print(InglishLettersStatistic.LETTERS[pos]);
		// // continue;
		// // }
		// // System.out.print(letter);
		// }
		// System.out.print(tex);
		// }
	}
}
